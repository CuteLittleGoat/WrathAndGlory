<!doctype html>
<html lang="pl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Generator NPC — Panel roboczy</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header class="topbar">
      <div class="brand">
        <h1>Generator NPC</h1>
      </div>
      <div class="actions">
        <button class="btn" id="reset-page">Reset</button>
        <button class="btn primary" id="generate-card">Generuj kartę</button>
      </div>
    </header>

    <main class="layout">
      <aside class="sidebar">
        <section class="panel">
          <h2>Źródło danych</h2>
          <p class="text-muted">
            Dane są pobierane z pliku
            <a class="link" href="https://cutelittlegoat.github.io/WrathAndGlory/DataVault/data.json">
              cutelittlegoat.github.io/WrathAndGlory/DataVault/data.json
            </a>
            , bez modyfikacji źródła.
          </p>
          <p class="text-muted" id="data-status" aria-live="polite">Ładowanie danych...</p>
        </section>

        <section class="panel">
          <h2>Wybór bazowy</h2>
          <div class="field">
            <label for="bestiary">Bestiariusz · Nazwa</label>
            <select id="bestiary">
              <option value="" disabled selected>Ładowanie danych...</option>
            </select>
          </div>
          <div class="field">
            <label for="bestiary-notes">Uwagi do rekordu</label>
            <textarea id="bestiary-notes" rows="3" placeholder="Opcjonalne notatki"></textarea>
          </div>
        </section>

        <section class="panel">
          <h2>Moduły aktywne</h2>
          <div class="checkbox-list">
            <label class="checkbox">
              <input type="checkbox" checked data-module-toggle="weapon" />
              <span>Broń — ustaw ataki i cechy.</span>
            </label>
            <label class="checkbox">
              <input type="checkbox" data-module-toggle="armor" />
              <span>Pancerz — nadpisz WP i cechy.</span>
            </label>
            <label class="checkbox">
              <input type="checkbox" data-module-toggle="augmentations" />
              <span>Augumentacje — moduł modyfikacji.</span>
            </label>
            <label class="checkbox">
              <input type="checkbox" data-module-toggle="equipment" />
              <span>Ekwipunek — lista przedmiotów.</span>
            </label>
            <label class="checkbox">
              <input type="checkbox" data-module-toggle="talents" />
              <span>Talenty — lista umiejętności.</span>
            </label>
            <label class="checkbox">
              <input type="checkbox" data-module-toggle="psionics" />
              <span>Psionika — lista zdolności.</span>
            </label>
            <label class="checkbox">
              <input type="checkbox" data-module-toggle="prayers" />
              <span>Modlitwy — lista zaklęć.</span>
            </label>
          </div>
        </section>

      </aside>

      <section class="workspace">
        <div class="card">
          <h3>Podgląd bazowy <span class="badge">Bestiariusz</span></h3>
          <table class="data-table" data-sheet="Bestiariusz">
            <thead>
              <tr>
                <th>Klucz</th>
                <th>Wartość</th>
              </tr>
            </thead>
            <tbody id="bestiary-table-body">
              <tr>
                <td colspan="2" class="text-muted">Ładowanie danych...</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="card" data-module-section="weapon">
          <div class="card-header">
            <h3>Wybór Broni</h3>
          </div>
          <div class="field">
            <div class="field-label-row">
              <label for="weapon">Bronie</label>
              <label class="checkbox checkbox-inline">
                <input type="checkbox" id="weapon-trait-descriptions" />
                <span>Czy dodać opis Cech?</span>
              </label>
            </div>
            <select id="weapon" multiple size="15">
              <option value="" disabled>Ładowanie danych...</option>
            </select>
          </div>
          <table class="data-table" data-sheet="Bronie">
            <thead>
              <tr>
                <th class="min-col-nazwa">Nazwa</th>
                <th class="min-col-obrazenia">Obrażenia</th>
                <th class="min-col-dk">DK</th>
                <th class="min-col-pp">PP</th>
                <th class="min-col-zasieg">Zasięg</th>
                <th class="min-col-szybkostrzelnosc">Szybkostrzelność</th>
                <th class="min-col-cechy">Cechy</th>
                <th class="min-col-slowa-kluczowe">Słowa Kluczowe</th>
                <th class="min-col-podrecznik">Podręcznik</th>
                <th class="min-col-strona">Strona</th>
              </tr>
            </thead>
            <tbody id="weapon-table-body">
              <tr>
                <td colspan="10" class="text-muted">Ładowanie danych...</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="card" data-module-section="armor">
          <div class="card-header">
            <h3>Wybór Pancerzy</h3>
          </div>
          <div class="field">
            <div class="field-label-row">
              <label for="armor">Pancerze</label>
              <label class="checkbox checkbox-inline">
                <input type="checkbox" id="armor-trait-descriptions" />
                <span>Czy dodać opis Cech?</span>
              </label>
            </div>
            <select id="armor" multiple size="15">
              <option value="" disabled>Ładowanie danych...</option>
            </select>
          </div>
          <table class="data-table" data-sheet="Pancerze">
            <thead>
              <tr>
                <th class="min-col-nazwa">Nazwa</th>
                <th class="min-col-wp">WP</th>
                <th class="min-col-cechy">Cechy</th>
                <th class="min-col-slowa-kluczowe">Słowa Kluczowe</th>
                <th class="min-col-podrecznik">Podręcznik</th>
                <th class="min-col-strona">Strona</th>
              </tr>
            </thead>
            <tbody id="armor-table-body">
              <tr>
                <td colspan="6" class="text-muted">Ładowanie danych...</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="card" data-module-section="augmentations">
          <div class="card-header">
            <h3>Wybór Augumentacji</h3>
          </div>
          <div class="field">
            <div class="field-label-row">
              <label for="augmentations">Augumentacje</label>
              <label class="checkbox checkbox-inline">
                <input type="checkbox" id="augmentations-full-details" />
                <span>Czy dodać pełen opis?</span>
              </label>
            </div>
            <select id="augmentations" multiple size="15">
              <option value="" disabled>Ładowanie danych...</option>
            </select>
          </div>
          <table class="data-table" data-sheet="Augumentacje">
            <thead>
              <tr>
                <th class="min-col-nazwa">Nazwa</th>
                <th class="min-col-efekt">Efekt</th>
              </tr>
            </thead>
            <tbody id="augmentations-table-body">
              <tr>
                <td colspan="2" class="text-muted">Ładowanie danych...</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="card" data-module-section="equipment">
          <div class="card-header">
            <h3>Wybór Ekwipunku</h3>
          </div>
          <div class="field">
            <div class="field-label-row">
              <label for="equipment">Ekwipunek</label>
              <label class="checkbox checkbox-inline">
                <input type="checkbox" id="equipment-full-details" />
                <span>Czy dodać pełen opis?</span>
              </label>
            </div>
            <select id="equipment" multiple size="15">
              <option value="" disabled>Ładowanie danych...</option>
            </select>
          </div>
          <table class="data-table" data-sheet="Ekwipunek">
            <thead>
              <tr>
                <th class="min-col-nazwa">Nazwa</th>
                <th class="min-col-efekt">Efekt</th>
              </tr>
            </thead>
            <tbody id="equipment-table-body">
              <tr>
                <td colspan="2" class="text-muted">Ładowanie danych...</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="card" data-module-section="talents">
          <div class="card-header">
            <h3>Wybór Talentów</h3>
          </div>
          <div class="field">
            <div class="field-label-row">
              <label for="talents">Talenty</label>
              <label class="checkbox checkbox-inline">
                <input type="checkbox" id="talents-full-details" />
                <span>Czy dodać pełen opis?</span>
              </label>
            </div>
            <select id="talents" multiple size="15">
              <option value="" disabled>Ładowanie danych...</option>
            </select>
          </div>
          <table class="data-table" data-sheet="Talenty">
            <thead>
              <tr>
                <th class="min-col-nazwa">Nazwa</th>
                <th class="min-col-efekt">Efekt</th>
              </tr>
            </thead>
            <tbody id="talents-table-body">
              <tr>
                <td colspan="2" class="text-muted">Ładowanie danych...</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="card" data-module-section="psionics">
          <div class="card-header">
            <h3>Wybór Psioniki</h3>
          </div>
          <div class="field">
            <div class="field-label-row">
              <label for="psionics">Psionika</label>
              <label class="checkbox checkbox-inline">
                <input type="checkbox" id="psionics-full-details" />
                <span>Czy dodać pełen opis?</span>
              </label>
            </div>
            <select id="psionics" multiple size="15">
              <option value="" disabled>Ładowanie danych...</option>
            </select>
          </div>
          <table class="data-table" data-sheet="Psionika">
            <thead>
              <tr>
                <th class="min-col-nazwa">Nazwa</th>
                <th class="min-col-st">ST</th>
                <th class="min-col-aktywacja">Aktywacja</th>
                <th class="min-col-czas-trwania">Czas trwania</th>
                <th class="min-col-zasieg">Zasięg</th>
                <th class="min-col-wiele-celow">Wiele Celów</th>
                <th class="min-col-efekt">Efekt</th>
                <th class="min-col-wzmocnienie">Wzmocnienie</th>
              </tr>
            </thead>
            <tbody id="psionics-table-body">
              <tr>
                <td colspan="8" class="text-muted">Ładowanie danych...</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="card" data-module-section="prayers">
          <div class="card-header">
            <h3>Wybór Modlitw</h3>
          </div>
          <div class="field">
            <div class="field-label-row">
              <label for="prayers">Modlitwy (wielokrotny wybór)</label>
              <label class="checkbox checkbox-inline">
                <input type="checkbox" id="prayers-full-details" />
                <span>Czy dodać pełen opis?</span>
              </label>
            </div>
            <select id="prayers" multiple size="15">
              <option value="" disabled>Ładowanie danych...</option>
            </select>
          </div>
          <table class="data-table" data-sheet="Modlitwy">
            <thead>
              <tr>
                <th class="min-col-nazwa">Nazwa</th>
                <th class="min-col-efekt">Efekt</th>
              </tr>
            </thead>
            <tbody id="prayers-table-body">
              <tr>
                <td colspan="2" class="text-muted">Ładowanie danych...</td>
              </tr>
            </tbody>
          </table>
        </div>

      </section>
    </main>

    <aside class="popover" id="trait-popover">
      <h4 id="trait-title">Opis cechy</h4>
      <p id="trait-description">Kliknij tag, aby zobaczyć opis cechy.</p>
    </aside>

    <script>
      const DATA_URL = "https://cutelittlegoat.github.io/WrathAndGlory/DataVault/data.json";

      const bestiarySelect = document.querySelector("#bestiary");
      const armorSelect = document.querySelector("#armor");
      const weaponSelect = document.querySelector("#weapon");
      const augmentationsSelect = document.querySelector("#augmentations");
      const equipmentSelect = document.querySelector("#equipment");
      const talentsSelect = document.querySelector("#talents");
      const psionicsSelect = document.querySelector("#psionics");
      const prayersSelect = document.querySelector("#prayers");
      const bestiaryTableBody = document.querySelector("#bestiary-table-body");
      const armorTableBody = document.querySelector("#armor-table-body");
      const weaponTableBody = document.querySelector("#weapon-table-body");
      const augmentationsTableBody = document.querySelector("#augmentations-table-body");
      const equipmentTableBody = document.querySelector("#equipment-table-body");
      const talentsTableBody = document.querySelector("#talents-table-body");
      const psionicsTableBody = document.querySelector("#psionics-table-body");
      const prayersTableBody = document.querySelector("#prayers-table-body");
      const dataStatus = document.querySelector("#data-status");
      const bestiaryNotes = document.querySelector("#bestiary-notes");
      const generateButton = document.querySelector("#generate-card");
      const resetButton = document.querySelector("#reset-page");
      const moduleToggles = Array.from(document.querySelectorAll("[data-module-toggle]"));
      const moduleSections = Array.from(document.querySelectorAll("[data-module-section]"));
      const armorTraitDescriptionsToggle = document.querySelector("#armor-trait-descriptions");
      const weaponTraitDescriptionsToggle = document.querySelector("#weapon-trait-descriptions");
      const augmentationsFullDetailsToggle = document.querySelector("#augmentations-full-details");
      const equipmentFullDetailsToggle = document.querySelector("#equipment-full-details");
      const talentsFullDetailsToggle = document.querySelector("#talents-full-details");
      const psionicsFullDetailsToggle = document.querySelector("#psionics-full-details");
      const prayersFullDetailsToggle = document.querySelector("#prayers-full-details");

      const popover = document.querySelector("#trait-popover");
      const popoverTitle = document.querySelector("#trait-title");
      const popoverDescription = document.querySelector("#trait-description");

      const CLAMP_LINES = 9;
      const MAX_NUMERIC_INPUT_LENGTH = 25;

      const state = {
        data: null,
        traits: new Map(),
        expandedCells: new Set(),
        selectedBestiaryIndex: null,
        bestiaryOverrides: {
          numeric: new Map(),
          skills: null,
          skillsEditing: false,
        },
        bestiary: [],
        armor: [],
        weapons: [],
        augmentations: [],
        equipment: [],
        talents: [],
        psionics: [],
        prayers: [],
      };

      const clampEvaluators = new WeakMap();
      const nameKeyCache = new WeakMap();
      const clampObserver = new ResizeObserver((entries) => {
        entries.forEach((entry) => {
          const target = entry.target;
          const evaluate = clampEvaluators.get(target);
          if (evaluate) {
            evaluate();
          }
        });
      });

      const normalizeText = (value) =>
        String(value ?? "")
          .replace(/\s+/g, " ")
          .trim();

      const normalizeKey = (value) =>
        normalizeText(value)
          .toLowerCase()
          .normalize("NFD")
          .replace(/\p{Diacritic}/gu, "");

      const EDITABLE_STATS_KEYS = [
        "S",
        "Wt",
        "Zr",
        "I",
        "SW",
        "Int",
        "Ogd",
        "Odporność (w tym WP)",
        "Obrona (w tym WP)",
        "Obrona",
        "Żywotność",
        "Odporność Psychiczna",
        "Upór",
        "Odwaga",
        "Szybkość",
      ];
      const EDITABLE_SKILLS_KEY = normalizeKey("Umiejętności");
      const EDITABLE_RESISTANCE_KEYS = new Set(
        ["Odporność (w tym WP)", "Obrona (w tym WP)"].map((label) => normalizeKey(label))
      );
      const EDITABLE_MENTAL_RESISTANCE_KEYS = new Set(
        ["Odporność Psychiczna", "Odporność psychiczna"].map((label) => normalizeKey(label))
      );
      const EDITABLE_NUMERIC_KEYS = new Set(EDITABLE_STATS_KEYS.map((label) => normalizeKey(label)));

      const escapeHtml = (value) =>
        String(value)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");

      const getColumnClass = (label) => {
        const slug = normalizeKey(label)
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/(^-|-$)/g, "");
        return slug ? `min-col-${slug}` : "";
      };

      const formatInlineHTML = (raw) => {
        const s = String(raw ?? "");
        const reRefParen = /\(([^)]*(?:\bstr\.?\b|\bstr\b|\bstrona\b)[^)]*)\)/gi;
        const markerRegex = /{{\/?(?:RED|B|I)}}/g;
        const segments = [];
        const stack = [];
        let cursor = 0;
        let match;

        while ((match = markerRegex.exec(s))) {
          if (match.index > cursor) {
            segments.push({ text: s.slice(cursor, match.index), styles: new Set(stack) });
          }
          const token = match[0];
          const isClose = token.startsWith("{{/");
          const name = token.includes("RED") ? "RED" : token.includes("B") ? "B" : "I";
          if (isClose) {
            const idx = stack.lastIndexOf(name);
            if (idx !== -1) stack.splice(idx, 1);
          } else {
            stack.push(name);
          }
          cursor = markerRegex.lastIndex;
        }
        if (cursor < s.length) {
          segments.push({ text: s.slice(cursor), styles: new Set(stack) });
        }

        const positions = [];
        let combined = "";
        for (const seg of segments) {
          const start = combined.length;
          combined += seg.text;
          positions.push({ seg, start, end: combined.length });
        }

        const refs = [];
        reRefParen.lastIndex = 0;
        while ((match = reRefParen.exec(combined))) {
          refs.push({ start: match.index, end: match.index + match[0].length });
        }

        const renderSegment = ({ text, styles }, start, end) => {
          const overlaps = refs.filter((r) => r.start < end && r.end > start);
          if (!overlaps.length) {
            const classes = [];
            if (styles?.has("RED")) classes.push("inline-red");
            if (styles?.has("B")) classes.push("inline-bold");
            if (styles?.has("I")) classes.push("inline-italic");
            const inner = escapeHtml(text);
            return classes.length ? `<span class="${classes.join(" ")}">${inner}</span>` : inner;
          }

          let localCursor = 0;
          const tokens = [];
          for (const ref of overlaps) {
            const localStart = Math.max(0, ref.start - start);
            const localEnd = Math.min(text.length, ref.end - start);
            if (localStart > localCursor) {
              tokens.push({ kind: "text", value: text.slice(localCursor, localStart) });
            }
            if (localEnd > localStart) {
              tokens.push({ kind: "ref", value: text.slice(localStart, localEnd) });
            }
            localCursor = Math.max(localCursor, localEnd);
          }
          if (localCursor < text.length) {
            tokens.push({ kind: "text", value: text.slice(localCursor) });
          }

          const styleClasses = [];
          if (styles?.has("RED")) styleClasses.push("inline-red");
          if (styles?.has("B")) styleClasses.push("inline-bold");
          if (styles?.has("I")) styleClasses.push("inline-italic");

          return tokens
            .map((token) => {
              const classes = [...styleClasses];
              if (token.kind === "ref") classes.push("ref");
              const inner = escapeHtml(token.value);
              return classes.length ? `<span class="${classes.join(" ")}">${inner}</span>` : inner;
            })
            .join("");
        };

        return positions.map((pos) => renderSegment(pos.seg, pos.start, pos.end)).join("");
      };

      const formatTextHTML = (raw, { maxLines = null, appendHint = null } = {}) => {
        const s = String(raw ?? "");
        if (!s) return "";
        const lines = s.split(/\r?\n/);
        const sliced = maxLines ? lines.slice(0, maxLines) : lines;
        const rendered = sliced.map((line) => {
          const marker = line.match(/^\*\s*\[(\d+)\]\s*(.*)$/);
          const highlight = Boolean(marker);
          const text = highlight ? `*[${marker[1]}] ${marker[2]}` : line;
          const inner = formatInlineHTML(text);
          return highlight ? `<span class="caretref">${inner}</span>` : inner;
        });
        if (maxLines && lines.length > maxLines && appendHint) {
          rendered.push(escapeHtml(appendHint));
        }
        return rendered.join("<br>");
      };

      const formatRangeHTML = (raw) => {
        const s = String(raw ?? "");
        if (!s) return "";
        const parts = s.split("/");
        if (parts.length === 1) return escapeHtml(s);
        return parts
          .map((part, idx) => {
            const seg = escapeHtml(part);
            if (idx === 0) return seg;
            return `<span class="slash">/</span>${seg}`;
          })
          .join("");
      };

      const formatKeywordHTML = (raw, { commasNeutral = false, maxLines = null, appendHint = null } = {}) => {
        const base = formatTextHTML(raw, { maxLines, appendHint });
        const body = commasNeutral ? base.replace(/,/g, '<span class="keyword-comma">,</span>') : base;
        return `<span class="keyword-red">${body}</span>`;
      };

      const isKeywordColumn = (key) => {
        const normalized = normalizeText(key).toLowerCase();
        return normalized === "słowa kluczowe" || normalized === "slowa kluczowe";
      };

      const isRangeColumn = (key) => {
        const normalized = normalizeText(key).toLowerCase();
        return normalized === "zasięg" || normalized === "zasieg";
      };

      const getFormattedCellHTML = (sheetName, key, rawValue, options = {}) => {
        if (isKeywordColumn(key)) {
          const commasNeutral = ["Bestiariusz", "Psionika", "Augumentacje", "Ekwipunek", "Pancerze", "Bronie"].includes(
            sheetName
          );
          return formatKeywordHTML(rawValue, { commasNeutral, ...options });
        }
        if (isRangeColumn(key)) {
          return formatRangeHTML(rawValue);
        }
        return formatTextHTML(rawValue, options);
      };

      const canonicalTraitName = (name) =>
        normalizeText(name).replace(/\(\s*\d+\s*\)/g, "(X)");

      const toDisplayString = (value) => {
        if (value === null || value === undefined || value === "") {
          return "—";
        }
        if (Array.isArray(value)) {
          return value.map((item) => toDisplayString(item)).join("; ");
        }
        if (typeof value === "object") {
          return Object.entries(value)
            .map(([key, val]) => `${key}: ${toDisplayString(val)}`)
            .join(", ");
        }
        return String(value);
      };

      const hasMeaningfulValue = (value) => {
        const normalized = normalizeText(value);
        return normalized && normalized !== "—" && normalized !== "-" && normalized !== "brak";
      };

      const parseNumericValue = (value, fallback = 1) => {
        const match = String(value ?? "").match(/-?\d+/);
        if (!match) {
          return fallback;
        }
        const numeric = Number(match[0]);
        return Number.isFinite(numeric) ? numeric : fallback;
      };

      const getRecordValueByLabels = (record, labels) => {
        for (const label of labels) {
          const value = getRecordValue(record, label);
          if (value !== null && value !== undefined && value !== "") {
            return value;
          }
        }
        return null;
      };

      const getBestiaryWpMinimum = (record) => {
        const wpText = normalizeText(getRecordValueByLabels(record, ["Wartość Pancerza", "WP"]));
        if (wpText === "-") {
          return 1;
        }
        const numeric = parseNumericValue(wpText, 1);
        return Math.max(1, numeric);
      };

      const getEditableNumericMinimum = (label, record) => {
        const normalizedLabel = normalizeKey(label);
        if (EDITABLE_RESISTANCE_KEYS.has(normalizedLabel)) {
          return getBestiaryWpMinimum(record);
        }
        return 1;
      };

      const getNumericOverride = (label) =>
        state.bestiaryOverrides.numeric.get(normalizeKey(label));

      const resetBestiaryOverrides = () => {
        state.bestiaryOverrides.numeric.clear();
        state.bestiaryOverrides.skills = null;
        state.bestiaryOverrides.skillsEditing = false;
      };

      const extractRecords = (section) => {
        if (!section) {
          return [];
        }
        if (Array.isArray(section)) {
          return section;
        }
        if (Array.isArray(section.rows)) {
          return section.rows;
        }
        if (Array.isArray(section.data)) {
          return section.data;
        }
        return [];
      };

      const getSectionName = (section) => {
        if (!section || typeof section !== "object") {
          return null;
        }
        const name =
          section.name ??
          section.nazwa ??
          section.Nazwa ??
          section.title ??
          section.Tytul ??
          section.Tytuł ??
          section.sheet ??
          section.sheetName ??
          section.Arkusz ??
          section.arkusz;
        return name ? normalizeText(name) : null;
      };

      const looksLikeRecordArray = (items) =>
        items.every(
          (item) =>
            item &&
            typeof item === "object" &&
            !Array.isArray(item) &&
            !("rows" in item) &&
            !("data" in item)
        );

      const findCollectionInNode = (node, keywords, visited) => {
        if (!node) {
          return null;
        }
        if (typeof node === "object") {
          if (visited.has(node)) {
            return null;
          }
          visited.add(node);
        }
        if (Array.isArray(node)) {
          if (!node.length) {
            return null;
          }
          const namedSections = node
            .map((section) => ({
              section,
              name: getSectionName(section),
            }))
            .filter((entry) => entry.name);
          if (namedSections.length) {
            for (const keyword of keywords) {
              const match = namedSections.find((entry) =>
                entry.name.toLowerCase().includes(keyword)
              );
              if (match) {
                const records = extractRecords(match.section);
                if (records.length) {
                  return records;
                }
              }
            }
          }
          if (looksLikeRecordArray(node)) {
            return node;
          }
          for (const section of node) {
            const records = extractRecords(section);
            if (records.length) {
              return records;
            }
            const nested = findCollectionInNode(section, keywords, visited);
            if (nested?.length) {
              return nested;
            }
          }
          return null;
        }
        if (typeof node === "object") {
          const directRecords = extractRecords(node);
          if (directRecords.length) {
            return directRecords;
          }
          const entries = Object.entries(node);
          for (const [key, value] of entries) {
            const lowerKey = key.toLowerCase();
            if (keywords.some((keyword) => lowerKey.includes(keyword))) {
              const records = findCollectionInNode(value, keywords, visited);
              if (records?.length) {
                return records;
              }
              const fallback = extractRecords(value);
              if (fallback.length) {
                return fallback;
              }
            }
          }
          for (const [, value] of entries) {
            const records = findCollectionInNode(value, keywords, visited);
            if (records?.length) {
              return records;
            }
          }
        }
        return null;
      };

      const getCollection = (db, keywords) => {
        if (!db || typeof db !== "object") {
          return [];
        }
        const records = findCollectionInNode(db, keywords, new WeakSet());
        return records ?? [];
      };

      const resolveNameKey = (record) => {
        if (!record || typeof record !== "object") {
          return null;
        }
        if (nameKeyCache.has(record)) {
          return nameKeyCache.get(record);
        }
        const keys = Object.keys(record);
        const nameKey =
          keys.find((key) => key.toLowerCase() === "nazwa") ||
          keys.find((key) => key.toLowerCase().includes("nazwa")) ||
          keys.find((key) => key.toLowerCase().includes("name")) ||
          keys[0];
        nameKeyCache.set(record, nameKey);
        return nameKey;
      };

      const getRecordName = (record, index) => {
        const key = resolveNameKey(record);
        const value = key ? record[key] : null;
        const name = normalizeText(value) || `Rekord ${index + 1}`;
        return name;
      };

      const compareStrings = (left, right, { descending = false } = {}) => {
        const normalizedLeft = normalizeText(left);
        const normalizedRight = normalizeText(right);
        const result = normalizedLeft.localeCompare(normalizedRight, "pl", { sensitivity: "base" });
        return descending ? -result : result;
      };

      const getSortableType = (record) =>
        normalizeText(getRecordValueByLabels(record, ["Typ", "Type", "type"]));

      const sortRecords = (records, compare) =>
        records
          .map((record, index) => ({ record, index }))
          .sort((a, b) => {
            const result = compare(a, b);
            if (result !== 0) {
              return result;
            }
            return a.index - b.index;
          })
          .map((entry) => entry.record);

      const sortByName = (records) =>
        sortRecords(records, (a, b) =>
          compareStrings(getRecordName(a.record, a.index), getRecordName(b.record, b.index))
        );

      const sortByTypeThenName = (records, { typeDescending = false } = {}) =>
        sortRecords(records, (a, b) => {
          const typeCompare = compareStrings(getSortableType(a.record), getSortableType(b.record), {
            descending: typeDescending,
          });
          if (typeCompare !== 0) {
            return typeCompare;
          }
          return compareStrings(getRecordName(a.record, a.index), getRecordName(b.record, b.index));
        });

      const findRecordKey = (record, label) => {
        if (!record) {
          return null;
        }
        const normalizedLabel = normalizeKey(label);
        const keys = Object.keys(record);
        const exact = keys.find((key) => normalizeKey(key) === normalizedLabel);
        if (exact) {
          return exact;
        }
        return keys.find((key) => normalizeKey(key).includes(normalizedLabel)) || null;
      };

      const getRecordValue = (record, label) => {
        const key = findRecordKey(record, label);
        return key ? record[key] : null;
      };

      const getArmorWpValue = (record) =>
        getRecordValue(record, "Wartość Pancerza") ?? getRecordValue(record, "WP");

      const isArmorBlocked = (record) => normalizeText(getArmorWpValue(record)) === "-";

      const isBestiaryArmorBlocked = (record) =>
        normalizeText(getRecordValueByLabels(record, ["Wartość Pancerza", "WP"])) === "-";

      const isBestiaryMentalResistanceBlocked = (record) =>
        normalizeText(
          getRecordValueByLabels(record, ["Odporność Psychiczna", "Odporność psychiczna"])
        ) === "-";

      const buildTraitsMap = (data) => {
        const traits = data?._meta?.traits;
        const map = new Map();
        if (!traits) {
          return map;
        }
        if (Array.isArray(traits)) {
          traits.forEach((trait) => {
            const traitName = trait?.Nazwa || trait?.name || trait?.Name;
            const traitDescription = trait?.Opis || trait?.description || trait?.Description;
            if (traitName) {
              map.set(canonicalTraitName(traitName), traitDescription || "");
            }
          });
          return map;
        }
        if (typeof traits === "object") {
          Object.entries(traits).forEach(([traitName, traitDescription]) => {
            if (traitName) {
              map.set(canonicalTraitName(traitName), traitDescription || "");
            }
          });
        }
        return map;
      };

      const resolveTraitDescription = (traitName) => {
        const canonical = canonicalTraitName(traitName);
        if (state.traits.has(canonical)) {
          return state.traits.get(canonical);
        }
        if (state.traits.has(normalizeText(traitName))) {
          return state.traits.get(normalizeText(traitName));
        }
        return "Opis cechy nie jest dostępny w _meta.traits.";
      };

      const setStatus = (message) => {
        dataStatus.textContent = message;
      };

      const updateModuleVisibility = () => {
        const moduleState = new Map(
          moduleToggles.map((toggle) => [toggle.dataset.moduleToggle, toggle.checked])
        );
        moduleSections.forEach((section) => {
          const key = section.dataset.moduleSection;
          if (!key || !moduleState.has(key)) {
            return;
          }
          section.classList.toggle("is-hidden", !moduleState.get(key));
        });
      };

      const setSelectOptions = (select, items, placeholder, { disableOption, disabledTitle } = {}) => {
        select.innerHTML = "";
        if (!items.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "Brak danych";
          option.disabled = true;
          option.selected = true;
          select.append(option);
          select.disabled = true;
          return;
        }
        if (!select.multiple) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = placeholder;
          option.disabled = true;
          option.selected = true;
          select.append(option);
        } else if (placeholder) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = placeholder;
          option.disabled = true;
          select.append(option);
        }
        items.forEach((record, index) => {
          const option = document.createElement("option");
          option.value = String(index);
          option.textContent = getRecordName(record, index);
          if (disableOption?.(record, index)) {
            option.disabled = true;
            option.title = disabledTitle || "";
          }
          select.append(option);
        });
        select.disabled = false;
      };

      const clearTableBody = (tbody, message, colSpan) => {
        tbody.innerHTML = "";
        const row = document.createElement("tr");
        const cell = document.createElement("td");
        cell.colSpan = colSpan;
        cell.className = "text-muted";
        cell.textContent = message;
        row.append(cell);
        tbody.append(row);
      };

      const createTag = (traitName) => {
        const span = document.createElement("span");
        span.className = "tag";
        span.textContent = traitName;
        span.setAttribute("data-trait", traitName);
        return span;
      };

      const renderTraitsCell = (value, columnClass) => {
        const cell = document.createElement("td");
        if (columnClass) {
          cell.classList.add(columnClass);
        }
        const valueString = toDisplayString(value);
        if (valueString === "—") {
          cell.textContent = valueString;
          return cell;
        }
        cell.classList.add("celltext");
        const traits = valueString
          .split(";")
          .map((trait) => normalizeText(trait))
          .filter(Boolean);
        if (!traits.length) {
          cell.textContent = "—";
          return cell;
        }
        traits.forEach((trait) => {
          cell.append(createTag(trait));
        });
        return cell;
      };

      const createClampCell = (sheetName, rowId, key, valueString, columnClass) => {
        const cell = document.createElement("td");
        if (columnClass) {
          cell.classList.add(columnClass);
        }
        if (valueString === "—") {
          cell.textContent = valueString;
          return cell;
        }
        cell.classList.add("celltext", "clamp-cell");
        const content = document.createElement("div");
        content.className = "clampable";
        const hint = document.createElement("div");
        hint.className = "clamp-hint";
        const keyId = `${sheetName}|${rowId}|${key}`;
        const rawText = String(valueString ?? "");
        const linesCount = rawText.split(/\r?\n/).length;
        const isClampCandidate = linesCount > CLAMP_LINES + 1;
        const renderCell = () => {
          content.innerHTML = getFormattedCellHTML(sheetName, key, valueString);
        };
        const evaluateClamp = () => {
          const lineHeight = parseFloat(getComputedStyle(content).lineHeight);
          if (!lineHeight) {
            cell.classList.remove("is-clampable", "is-clamped", "is-expanded");
            content.style.maxHeight = "";
            content.style.overflow = "";
            hint.textContent = "";
            return;
          }
          const linesRendered = Math.round(content.scrollHeight / lineHeight);
          const shouldClamp = isClampCandidate || linesRendered > CLAMP_LINES;
          if (!shouldClamp) {
            cell.classList.remove("is-clampable", "is-clamped", "is-expanded");
            content.style.maxHeight = "";
            content.style.overflow = "";
            cell.title = "";
            hint.textContent = "";
            return;
          }
          cell.classList.add("is-clampable");
          const isExpanded = state.expandedCells.has(keyId);
          cell.classList.toggle("is-expanded", isExpanded);
          cell.classList.toggle("is-clamped", !isExpanded);
          if (!isExpanded) {
            content.style.maxHeight = `${lineHeight * CLAMP_LINES}px`;
            content.style.overflow = "hidden";
          } else {
            content.style.maxHeight = "";
            content.style.overflow = "";
          }
          hint.textContent = isExpanded ? "Kliknij aby zwinąć" : "Kliknij aby rozwinąć";
          cell.title = hint.textContent;
        };
        renderCell();
        cell.append(content, hint);
        clampEvaluators.set(content, evaluateClamp);
        clampObserver.observe(content);
        requestAnimationFrame(evaluateClamp);
        cell.addEventListener("click", () => {
          if (!cell.classList.contains("is-clampable")) {
            return;
          }
          if (state.expandedCells.has(keyId)) {
            state.expandedCells.delete(keyId);
          } else {
            state.expandedCells.add(keyId);
          }
          renderCell();
          requestAnimationFrame(evaluateClamp);
        });
        return cell;
      };

      const createNumericInputCell = (record, key, valueString) => {
        const cell = document.createElement("td");
        cell.classList.add("celltext");
        const input = document.createElement("input");
        input.type = "number";
        input.className = "input table-number-input";
        input.maxLength = MAX_NUMERIC_INPUT_LENGTH;
        const minValue = getEditableNumericMinimum(key, record);
        input.min = String(minValue);
        input.step = "1";
        const overrideValue = getNumericOverride(key);
        const initial = overrideValue ?? parseNumericValue(valueString, minValue);
        const resolvedInitial = Math.max(minValue, Number.isFinite(initial) ? initial : minValue);
        const clampInputLength = () => {
          if (input.value.length > MAX_NUMERIC_INPUT_LENGTH) {
            input.value = input.value.slice(0, MAX_NUMERIC_INPUT_LENGTH);
          }
        };
        input.value = String(resolvedInitial);
        clampInputLength();
        const commitValue = () => {
          clampInputLength();
          const numeric = parseNumericValue(input.value, minValue);
          const resolved = Math.max(minValue, numeric);
          input.value = String(resolved);
          clampInputLength();
          state.bestiaryOverrides.numeric.set(normalizeKey(key), resolved);
        };
        input.addEventListener("input", () => {
          clampInputLength();
          const numeric = Number.parseInt(input.value, 10);
          if (Number.isFinite(numeric)) {
            state.bestiaryOverrides.numeric.set(normalizeKey(key), Math.max(minValue, numeric));
          }
        });
        input.addEventListener("change", commitValue);
        input.addEventListener("blur", commitValue);
        cell.append(input);
        return cell;
      };

      const createSkillsRow = (record, key, valueString) => {
        const row = document.createElement("tr");
        const keyCell = document.createElement("td");
        keyCell.classList.add("skills-key-cell");
        const label = document.createElement("span");
        label.textContent = key;
        const button = document.createElement("button");
        button.type = "button";
        button.className = "btn secondary btn-small";
        const isEditing = state.bestiaryOverrides.skillsEditing;
        button.textContent = isEditing ? "Zapisz" : "Edytuj";
        keyCell.append(label, button);
        row.append(keyCell);

        if (isEditing) {
          const valueCell = document.createElement("td");
          const textarea = document.createElement("textarea");
          textarea.className = "editable-textarea";
          const currentValue = state.bestiaryOverrides.skills ?? valueString;
          textarea.value = currentValue === "—" ? "" : currentValue;
          valueCell.append(textarea);
          row.append(valueCell);
          button.addEventListener("click", () => {
            state.bestiaryOverrides.skills = textarea.value;
            state.bestiaryOverrides.skillsEditing = false;
            renderBestiaryTable(record);
          });
        } else {
          const displayValue = state.bestiaryOverrides.skills ?? valueString;
          row.append(createClampCell("Bestiariusz", key, key, displayValue));
          button.addEventListener("click", () => {
            state.bestiaryOverrides.skillsEditing = true;
            renderBestiaryTable(record);
          });
        }
        return row;
      };

      const renderOrderedTable = ({
        tableBody,
        records,
        selectedIndices,
        columns,
        sheetName,
        emptyMessage,
      }) => {
        if (!selectedIndices.length) {
          clearTableBody(tableBody, emptyMessage, columns.length);
          return;
        }
        tableBody.innerHTML = "";
        selectedIndices.forEach((index) => {
          const record = records[index];
          if (!record) {
            return;
          }
          const row = document.createElement("tr");
          columns.forEach((label) => {
            const columnClass = getColumnClass(label);
            if (label.toLowerCase().includes("cechy")) {
              row.append(renderTraitsCell(getRecordValue(record, label), columnClass));
              return;
            }
            const valueString = toDisplayString(getRecordValue(record, label));
            row.append(createClampCell(sheetName, index, label, valueString, columnClass));
          });
          tableBody.append(row);
        });
      };

      const renderBestiaryTable = (record) => {
        if (!record) {
          clearTableBody(bestiaryTableBody, "Wybierz rekord bestiariusza.", 2);
          return;
        }
        bestiaryTableBody.innerHTML = "";
        const entries = Object.entries(record);
        entries.forEach(([key, value]) => {
          const valueString = toDisplayString(value);
          const normalizedKey = normalizeKey(key);
          if (normalizedKey === EDITABLE_SKILLS_KEY) {
            bestiaryTableBody.append(createSkillsRow(record, key, valueString));
            return;
          }
          const row = document.createElement("tr");
          const keyCell = document.createElement("td");
          keyCell.textContent = key;
          row.append(keyCell);

          let valueCell;
          if (key.toLowerCase().includes("cechy")) {
            valueCell = renderTraitsCell(value);
          } else if (EDITABLE_NUMERIC_KEYS.has(normalizedKey)) {
            if (EDITABLE_MENTAL_RESISTANCE_KEYS.has(normalizedKey) && isBestiaryMentalResistanceBlocked(record)) {
              valueCell = createClampCell("Bestiariusz", key, key, valueString);
            } else {
              valueCell = createNumericInputCell(record, key, valueString);
            }
          } else {
            valueCell = createClampCell("Bestiariusz", key, key, valueString);
          }
          row.append(valueCell);
          bestiaryTableBody.append(row);
        });
      };

      const weaponColumns = [
        "Nazwa",
        "Obrażenia",
        "DK",
        "PP",
        "Zasięg",
        "Szybkostrzelność",
        "Cechy",
        "Słowa Kluczowe",
        "Podręcznik",
        "Strona",
      ];

      const armorColumns = ["Nazwa", "WP", "Cechy", "Słowa Kluczowe", "Podręcznik", "Strona"];
      const augmentationsColumns = ["Nazwa", "Efekt"];
      const equipmentColumns = ["Nazwa", "Efekt"];
      const talentsColumns = ["Nazwa", "Efekt"];
      const psionicsColumns = [
        "Nazwa",
        "ST",
        "Aktywacja",
        "Czas trwania",
        "Zasięg",
        "Wiele Celów",
        "Efekt",
        "Wzmocnienie",
      ];
      const prayersColumns = ["Nazwa", "Efekt"];

      const getSelectedIndices = (select) =>
        Array.from(select.selectedOptions)
          .map((option) => Number(option.value))
          .filter((index) => !Number.isNaN(index));

      const renderWeaponTable = () => {
        const selected = getSelectedIndices(weaponSelect);
        renderOrderedTable({
          tableBody: weaponTableBody,
          records: state.weapons,
          selectedIndices: selected,
          columns: weaponColumns,
          sheetName: "Bronie",
          emptyMessage: "Wybierz broń, aby zobaczyć parametry.",
        });
      };

      const renderArmorTable = () => {
        const selected = getSelectedIndices(armorSelect);
        renderOrderedTable({
          tableBody: armorTableBody,
          records: state.armor,
          selectedIndices: selected,
          columns: armorColumns,
          sheetName: "Pancerze",
          emptyMessage: "Wybierz pancerz, aby zobaczyć parametry.",
        });
      };

      const renderAugmentationsTable = () => {
        const selected = getSelectedIndices(augmentationsSelect);
        renderOrderedTable({
          tableBody: augmentationsTableBody,
          records: state.augmentations,
          selectedIndices: selected,
          columns: augmentationsColumns,
          sheetName: "Augumentacje",
          emptyMessage: "Wybierz augumentacje, aby zobaczyć parametry.",
        });
      };

      const renderEquipmentTable = () => {
        const selected = getSelectedIndices(equipmentSelect);
        renderOrderedTable({
          tableBody: equipmentTableBody,
          records: state.equipment,
          selectedIndices: selected,
          columns: equipmentColumns,
          sheetName: "Ekwipunek",
          emptyMessage: "Wybierz ekwipunek, aby zobaczyć parametry.",
        });
      };

      const renderTalentsTable = () => {
        const selected = getSelectedIndices(talentsSelect);
        renderOrderedTable({
          tableBody: talentsTableBody,
          records: state.talents,
          selectedIndices: selected,
          columns: talentsColumns,
          sheetName: "Talenty",
          emptyMessage: "Wybierz talent, aby zobaczyć parametry.",
        });
      };

      const renderPsionicsTable = () => {
        const selected = getSelectedIndices(psionicsSelect);
        renderOrderedTable({
          tableBody: psionicsTableBody,
          records: state.psionics,
          selectedIndices: selected,
          columns: psionicsColumns,
          sheetName: "Psionika",
          emptyMessage: "Wybierz psionikę, aby zobaczyć parametry.",
        });
      };

      const renderPrayersTable = () => {
        const selected = getSelectedIndices(prayersSelect);
        renderOrderedTable({
          tableBody: prayersTableBody,
          records: state.prayers,
          selectedIndices: selected,
          columns: prayersColumns,
          sheetName: "Modlitwy",
          emptyMessage: "Wybierz modlitwę, aby zobaczyć parametry.",
        });
      };

      const setArmorSelectionEnabled = (enabled) => {
        armorSelect.disabled = !enabled;
        if (!enabled) {
          Array.from(armorSelect.options).forEach((option) => {
            option.selected = false;
          });
          renderArmorTable();
        }
      };

      const updateBestiarySelection = () => {
        const index = Number(bestiarySelect.value);
        if (Number.isNaN(index)) {
          state.selectedBestiaryIndex = null;
          resetBestiaryOverrides();
          renderBestiaryTable(null);
          setArmorSelectionEnabled(true);
          return;
        }
        if (state.selectedBestiaryIndex !== index) {
          state.selectedBestiaryIndex = index;
          resetBestiaryOverrides();
        }
        const record = state.bestiary[index];
        renderBestiaryTable(record);
        setArmorSelectionEnabled(!isBestiaryArmorBlocked(record));
      };

      const splitEntries = (raw) => {
        const value = String(raw ?? "");
        if (!hasMeaningfulValue(value)) {
          return [];
        }
        const entryStartRegex =
          /^\s*(?:\*\s*\[\d+\]|\[\d+\]|[^—]{1,60}\s—|[^—]{1,40}:\s)/;
        const lines = value
          .split(/\r?\n/)
          .map((entry) => entry.trim())
          .filter(Boolean);
        const entries = [];
        let current = "";
        lines.forEach((line) => {
          if (!current) {
            current = line;
            return;
          }
          if (entryStartRegex.test(line)) {
            entries.push(current);
            current = line;
          } else {
            current = `${current} ${line}`;
          }
        });
        if (current) {
          entries.push(current);
        }
        return entries;
      };

      const formatSectionEntries = (entries) =>
        entries
          .map((entry, index) => {
            const className = index % 2 === 1 ? "entry entry-alt" : "entry";
            return `<div class="${className}">${formatInlineHTML(entry)}</div>`;
          })
          .join("");

      const getSelectedRecords = (records, selectedIndices) =>
        selectedIndices.map((index) => records[index]).filter(Boolean);

      const getTraitNamesFromRecords = (records) => {
        const seen = new Map();
        records.forEach((record) => {
          const rawTraits = getRecordValue(record, "Cechy");
          if (!hasMeaningfulValue(rawTraits)) {
            return;
          }
          String(rawTraits)
            .split(/[;,]/)
            .map((trait) => normalizeText(trait))
            .filter(Boolean)
            .forEach((trait) => {
              const canonical = canonicalTraitName(trait);
              if (!seen.has(canonical)) {
                seen.set(canonical, trait);
              }
            });
        });
        return Array.from(seen.entries()).map(([canonical, label]) => ({ canonical, label }));
      };

      const buildTraitDescriptionLine = (records, label) => {
        const traits = getTraitNamesFromRecords(records);
        if (!traits.length) {
          return null;
        }
        const descriptions = traits
          .map(({ label: traitLabel }) => {
            const description = resolveTraitDescription(traitLabel);
            return `{{B}}${traitLabel}{{/B}} — ${description}`;
          })
          .filter(hasMeaningfulValue);
        if (!descriptions.length) {
          return null;
        }
        return `${label}: ${descriptions.join("; ")}`;
      };

      const parseArmorWpValue = (value) => {
        const text = normalizeText(value);
        if (text === "-") {
          return { text, numeric: 0, hasStar: false };
        }
        if (!hasMeaningfulValue(text)) {
          return null;
        }
        const hasStar = text.includes("*");
        const numberMatch = text.match(/-?\d+/);
        const numeric = numberMatch ? Number(numberMatch[0]) : null;
        return { text, numeric, hasStar };
      };

      const getArmorOverrides = (records, { includeTraitDescriptions = false } = {}) => {
        const eligibleRecords = records.filter((record) => !isArmorBlocked(record));
        if (!eligibleRecords.length) {
          return null;
        }
        const wpValues = eligibleRecords
          .map((record) => parseArmorWpValue(getArmorWpValue(record)))
          .filter(Boolean);
        if (!wpValues.length) {
          return null;
        }
        const numericValues = wpValues.filter((entry) => Number.isFinite(entry.numeric));
        const bestWp = numericValues.length
          ? numericValues.reduce((best, current) => (current.numeric > best.numeric ? current : best))
          : wpValues[0];
        const hasStar = wpValues.some((entry) => entry.hasStar);
        const traits = eligibleRecords
          .flatMap((record) =>
            String(getRecordValue(record, "Cechy") ?? "")
              .split(/[;,]/)
              .map((trait) => normalizeText(trait))
              .filter(Boolean)
          )
          .filter((trait, index, list) => list.indexOf(trait) === index);
        const traitDescriptionLine = includeTraitDescriptions
          ? buildTraitDescriptionLine(eligibleRecords, "Opis cech pancerza")
          : null;
        return {
          wpText: bestWp?.text ?? "",
          traits,
          hasStar,
          traitDescriptionLine,
        };
      };

      const buildWeaponEntry = (record) => {
        if (!record) {
          return "";
        }
        const name = toDisplayString(getRecordValue(record, "Nazwa"));
        const fields = [
          ["Obrażenia", "Obrażenia"],
          ["DK", "DK"],
          ["PP", "PP"],
          ["Zasięg", "Zasięg"],
          ["Szybkostrzelność", "Szybkostrzelność"],
          ["Cechy", "Cechy"],
        ];
        const details = fields
          .map(([label, key]) => {
            const value = toDisplayString(getRecordValue(record, key));
            return hasMeaningfulValue(value) ? `${label}: ${value}` : null;
          })
          .filter(Boolean)
          .join(", ");
        if (hasMeaningfulValue(details)) {
          return `${name} — ${details}`;
        }
        return name;
      };

      const buildWeaponOverride = (records, { includeTraitDescriptions = false } = {}) => {
        if (!records.length) {
          return null;
        }
        const entries = records.map((record) => buildWeaponEntry(record)).filter(hasMeaningfulValue);
        if (!entries.length) {
          return null;
        }
        const traitDescriptionLine = includeTraitDescriptions
          ? buildTraitDescriptionLine(records, "Opis cech broni")
          : null;
        return {
          entries: entries.join("\n"),
          traitDescriptionLine,
        };
      };

      const buildModuleEntries = (records, columns, { includeFull, normalizeColumns = [] } = {}) => {
        if (!records.length) {
          return "";
        }
        const entries = records
          .map((record) => {
            const name = toDisplayString(getRecordValue(record, "Nazwa"));
            if (!includeFull) {
              return hasMeaningfulValue(name) ? name : "";
            }
            const details = columns
              .filter((column) => column !== "Nazwa")
              .map((column) => {
                const rawValue = getRecordValue(record, column);
                let value = toDisplayString(rawValue);
                if (normalizeColumns.includes(column)) {
                  value = normalizeText(value);
                }
                return hasMeaningfulValue(value) ? `${column}: ${value}` : null;
              })
              .filter(Boolean)
              .join(", ");
            if (hasMeaningfulValue(details)) {
              return `${name} — ${details}`;
            }
            return name;
          })
          .filter(hasMeaningfulValue);
        return entries.join("\n");
      };

      const normalizeStarPrefix = (value, hasStar) => {
        if (!hasMeaningfulValue(value)) {
          return value;
        }
        const cleanValue = String(value).replace(/\*/g, "").trim();
        return hasStar ? `*${cleanValue}` : cleanValue;
      };

      const formatNumericWithStar = (numeric, hasStar, fallbackText) => {
        if (Number.isFinite(numeric)) {
          return normalizeStarPrefix(String(numeric), hasStar);
        }
        return normalizeStarPrefix(fallbackText, hasStar);
      };

      const parseStarNumber = (value) => {
        const text = normalizeText(value);
        if (!hasMeaningfulValue(text)) {
          return null;
        }
        const hasStar = text.includes("*");
        const numberMatch = text.match(/-?\d+/);
        const numeric = numberMatch ? Number(numberMatch[0]) : null;
        return { text, numeric, hasStar };
      };

      const extractWpFromResistance = (value) => {
        const text = normalizeText(value);
        if (!hasMeaningfulValue(text)) {
          return null;
        }
        const match = text.match(/WP[:\s]*(-?\d+)/i);
        if (!match) {
          return null;
        }
        return Number(match[1]);
      };

      const buildPrintableCardHTML = (
        record,
        notes,
        { weaponOverride, armorOverride, moduleEntries, bestiaryOverrides } = {}
      ) => {
        const name = toDisplayString(getRecordValue(record, "Nazwa"));
        const keywords = toDisplayString(getRecordValue(record, "Słowa Kluczowe"));
        const threatRaw = toDisplayString(getRecordValue(record, "Zagrożenie"));
        const threatLetters =
          threatRaw.match(/[A-Za-zĄĆĘŁŃÓŚŹŻ]/g)?.slice(0, 4) ||
          threatRaw.split("").filter(Boolean).slice(0, 4);
        while (threatLetters.length < 4) {
          threatLetters.push("");
        }

        const numericOverrides = bestiaryOverrides?.numeric ?? new Map();
        const skillsOverride = bestiaryOverrides?.skills;
        const getNumericOverrideValue = (label) => numericOverrides.get(normalizeKey(label));
        const resolveNumericDisplay = (label, fallbackValue) => {
          const override = getNumericOverrideValue(label);
          return override != null ? String(override) : toDisplayString(fallbackValue);
        };
        const resolveTrackerCount = (value) => {
          const parsed = parseStarNumber(value);
          if (!Number.isFinite(parsed?.numeric)) {
            return 0;
          }
          return Math.max(0, parsed.numeric);
        };

        const stats = {
          S: resolveNumericDisplay("S", getRecordValue(record, "S")),
          Wt: resolveNumericDisplay("Wt", getRecordValue(record, "Wt")),
          Zr: resolveNumericDisplay("Zr", getRecordValue(record, "Zr")),
          I: resolveNumericDisplay("I", getRecordValue(record, "I")),
          SW: resolveNumericDisplay("SW", getRecordValue(record, "SW")),
          Int: resolveNumericDisplay("Int", getRecordValue(record, "Int")),
          Ogd: resolveNumericDisplay("Ogd", getRecordValueByLabels(record, ["Ogd", "Ocd"])),
        };

        const resistanceOverride =
          getNumericOverrideValue("Odporność (w tym WP)") ?? getNumericOverrideValue("Obrona (w tym WP)");
        let resistance =
          resistanceOverride != null
            ? String(resistanceOverride)
            : toDisplayString(getRecordValueByLabels(record, ["Odporność (w tym WP)", "Obrona (w tym WP)"]));
        let wp = toDisplayString(getRecordValueByLabels(record, ["Wartość Pancerza", "WP"]));
        const baseResistance = parseStarNumber(resistance);
        const baseWp = parseStarNumber(wp);
        const baseWpNumeric =
          baseWp && Number.isFinite(baseWp.numeric) ? baseWp.numeric : extractWpFromResistance(resistance);
        if (armorOverride?.wpText) {
          const armorWp = parseStarNumber(armorOverride.wpText);
          const armorHasStar = Boolean(
            armorOverride.hasStar || armorWp?.hasStar || baseResistance?.hasStar || baseWp?.hasStar
          );
          let finalResistance = resistance;
          let finalResistanceNumeric = null;
          if (Number.isFinite(baseResistance?.numeric) && Number.isFinite(armorWp?.numeric)) {
            const resolvedBaseWp = Number.isFinite(baseWpNumeric) ? baseWpNumeric : 0;
            const baseResistanceNumeric = baseResistance.numeric - resolvedBaseWp;
            finalResistanceNumeric = baseResistanceNumeric + armorWp.numeric;
            finalResistance = String(finalResistanceNumeric);
          }
          const finalWpNumeric = armorWp?.numeric ?? null;
          const finalWp = finalWpNumeric != null ? String(finalWpNumeric) : armorOverride.wpText;
          resistance = formatNumericWithStar(finalResistanceNumeric, armorHasStar, finalResistance);
          wp = formatNumericWithStar(finalWpNumeric, armorHasStar, finalWp);
        } else {
          resistance = normalizeStarPrefix(resistance, baseResistance?.hasStar);
          wp = normalizeStarPrefix(wp, baseWp?.hasStar);
        }
        const wpDisplay = hasMeaningfulValue(wp) ? `${escapeHtml(wp)}` : "";
        const resistanceLine =
          hasMeaningfulValue(wp) && !String(resistance).includes("WP")
            ? `${escapeHtml(resistance)} <span class="resistance-wp">(w tym Pancerz: ${wpDisplay})</span>`
            : escapeHtml(resistance);
        const armorTraitsLine = armorOverride?.traits?.length
          ? `Cechy Pancerza: ${armorOverride.traits
              .map((trait) => `{{B}}${trait}{{/B}}`)
              .join("; ")}`
          : "";
        const armorTraitDescriptionsLine = armorOverride?.traitDescriptionLine || "";
        const armorTraitsHTML = armorTraitsLine
          ? `
            <div class="section-body armor-traits">${formatInlineHTML(armorTraitsLine)}</div>
            ${
              armorTraitDescriptionsLine
                ? `<div class="section-body armor-traits-desc">${formatInlineHTML(
                    armorTraitDescriptionsLine
                  )}</div>`
                : ""
            }
          `
          : "";

        const defense = resolveNumericDisplay("Obrona", getRecordValue(record, "Obrona"));
        const vitality = resolveNumericDisplay("Żywotność", getRecordValue(record, "Żywotność"));
        const mentalOverride = getNumericOverrideValue("Odporność Psychiczna");
        const mental =
          mentalOverride != null
            ? String(mentalOverride)
            : toDisplayString(
                getRecordValueByLabels(record, ["Odporność Psychiczna", "Odporność psychiczna"])
              );
        const vitalityCount = resolveTrackerCount(vitality);
        const mentalText = normalizeText(mental);
        const mentalHasDash = mentalText === "-";
        const mentalCount = mentalHasDash ? 0 : resolveTrackerCount(mental);
        const vitalityTrackerCells = Array.from(
          { length: vitalityCount },
          () => '<div class="tracker-cell" aria-hidden="true"></div>'
        ).join("");
        const mentalTrackerCells = Array.from(
          { length: mentalCount },
          () => '<div class="tracker-cell" aria-hidden="true"></div>'
        ).join("");
        const trackerHTML = `
          <div class="tracker-section" aria-label="Śledzenie Żywotności i Odporności Psychicznej">
            <div class="tracker-grid" data-count="${vitalityCount}">
              <div class="tracker-cell tracker-label">Ż</div>
              ${vitalityTrackerCells}
            </div>
            <div class="tracker-grid tracker-grid--mental" data-count="${mentalCount}">
              <div class="tracker-cell tracker-label">T</div>
              ${mentalTrackerCells}
            </div>
          </div>
        `;

        const skills =
          skillsOverride != null ? skillsOverride : toDisplayString(getRecordValue(record, "Umiejętności"));
        const bonuses = toDisplayString(getRecordValue(record, "Premie"));
        const abilities = toDisplayString(getRecordValue(record, "Zdolności"));
        let attacks = weaponOverride?.entries ?? toDisplayString(getRecordValue(record, "Atak"));
        if (weaponOverride?.traitDescriptionLine && hasMeaningfulValue(attacks)) {
          attacks = `${attacks}\n${weaponOverride.traitDescriptionLine}`;
        }
        const hordeAbilities = toDisplayString(getRecordValue(record, "Zdolności Hordy"));
        const hordeOptions = toDisplayString(getRecordValue(record, "Opcje Hordy"));

        const grit = resolveNumericDisplay("Upór", getRecordValue(record, "Upór"));
        const courage = resolveNumericDisplay("Odwaga", getRecordValue(record, "Odwaga"));
        const speed = resolveNumericDisplay("Szybkość", getRecordValue(record, "Szybkość"));
        const size = toDisplayString(getRecordValue(record, "Rozmiar"));

        const sections = [
          { label: "Umiejętności", value: skills, striped: false },
          { label: "Premie", value: bonuses, striped: true },
          { label: "Zdolności", value: abilities, striped: true },
          { label: "Atak", value: attacks, striped: true },
          { label: "Zdolności Hordy", value: hordeAbilities, striped: true },
          { label: "Opcje Hordy", value: hordeOptions, striped: true },
        ];
        (moduleEntries ?? []).forEach((entry) => {
          if (entry?.label && hasMeaningfulValue(entry.value)) {
            sections.push({ label: entry.label, value: entry.value, striped: true });
          }
        });

        const sectionHTML = sections
          .filter((section) => hasMeaningfulValue(section.value))
          .map((section) => {
            if (section.striped) {
              const entries = splitEntries(section.value);
              return `
                <div class="section-header">${escapeHtml(section.label)}</div>
                <div class="section-body striped">${formatSectionEntries(entries)}</div>
              `;
            }
            return `
              <div class="section-header">${escapeHtml(section.label)}</div>
              <div class="section-body">${formatTextHTML(section.value)}</div>
            `;
          })
          .join("");

        const notesValue = normalizeText(notes);
        const notesHTML = notesValue
          ? `
            <div class="section-header">Notatki</div>
            <div class="section-body">${escapeHtml(notesValue)}</div>
          `
          : "";

        return `
          <!doctype html>
          <html lang="pl">
            <head>
              <meta charset="utf-8" />
              <meta name="viewport" content="width=device-width, initial-scale=1" />
              <title>${escapeHtml(name)} — Karta</title>
              <style>
                * { box-sizing: border-box; }
                body { margin: 0; background: #fff; color: #111; font-family: "Times New Roman", "Liberation Serif", serif; }
                .card { width: min(760px, 95vw); margin: 24px auto; border: 1px solid #111; }
                .title { background: #2c2c2c; color: #fff; text-align: center; text-transform: uppercase; letter-spacing: 0.08em; font-weight: 700; padding: 8px 12px; }
                .row { display: grid; grid-template-columns: 140px repeat(4, 1fr); border-bottom: 1px solid #111; }
                .row .cell { padding: 6px 8px; border-right: 1px solid #111; text-align: center; }
                .row .cell:last-child { border-right: none; }
                .row .label { text-align: left; font-weight: 700; }
                .keywords { padding: 6px 8px; border-bottom: 1px solid #111; }
                .keywords .label { font-weight: 700; margin-right: 6px; }
                .keywords .value { text-transform: uppercase; letter-spacing: 0.04em; }
                .stats { display: grid; grid-template-columns: repeat(7, 1fr); border-bottom: 1px solid #111; }
                .stats .cell { padding: 6px 6px; text-align: center; border-right: 1px solid #111; }
                .stats .cell:last-child { border-right: none; }
                .stats.labels .cell { font-weight: 700; background: #f1f1f1; }
                .section-header { background: #2c2c2c; color: #fff; text-transform: uppercase; font-weight: 700; padding: 6px 8px; border-bottom: 1px solid #111; }
                .section-header.centered { text-align: center; }
                .section-body { padding: 8px; border-bottom: 1px solid #111; font-size: 0.95rem; line-height: 1.35; }
                .section-body.centered { text-align: center; }
                .section-body.striped { padding: 0; }
                .entry { padding: 8px; border-bottom: 1px solid #d0d0d0; }
                .entry:last-child { border-bottom: none; }
                .entry-alt { background: #e9e9e9; }
                .triple { display: grid; grid-template-columns: repeat(3, 1fr); border-bottom: 1px solid #111; }
                .quad { display: grid; grid-template-columns: repeat(4, 1fr); border-bottom: 1px solid #111; }
                .triple .cell, .quad .cell { padding: 6px; text-align: center; border-right: 1px solid #111; }
                .triple .cell:last-child, .quad .cell:last-child { border-right: none; }
                .triple.labels .cell, .quad.labels .cell { font-weight: 700; background: #f1f1f1; }
                .tracker-section { padding: 6px 8px; border-bottom: 1px solid #111; display: grid; gap: 6px; }
                .tracker-grid { --tracker-size: 18px; --tracker-gap: 1px; --tracker-columns: 10; --tracker-rows: 1; display: grid; grid-template-columns: repeat(var(--tracker-columns), var(--tracker-size)); grid-auto-rows: var(--tracker-size); gap: var(--tracker-gap); background: #111; padding: var(--tracker-gap); justify-content: start; width: 100%; }
                .tracker-cell { background: var(--tracker-fill, #fff); display: flex; align-items: center; justify-content: center; font-size: 0.85rem; color: #111; }
                .tracker-label { font-weight: 700; grid-column: 1; grid-row: span var(--tracker-rows); }
                .tracker-grid--mental { --tracker-fill: #e9e9e9; }
                .resistance-wp { font-weight: 700; }
                .armor-traits { text-align: left; }
                .armor-traits-desc { text-align: left; }
                .inline-red, .keyword-red { color: #111; }
                .inline-bold { font-weight: 700; }
                .inline-italic { font-style: italic; }
                .ref { color: #111; text-decoration: underline; }
                .caretref { color: #111; }
                .slash { color: #111; }
                @media print { body { margin: 0; } .card { margin: 0 auto; } }
              </style>
            </head>
            <body>
              <div class="card">
                <div class="title">${escapeHtml(name)}</div>
                <div class="row">
                  <div class="cell label">Poziom</div>
                  <div class="cell">1</div>
                  <div class="cell">2</div>
                  <div class="cell">3</div>
                  <div class="cell">4</div>
                </div>
                <div class="row">
                  <div class="cell label">Zagrożenie</div>
                  ${threatLetters
                    .map((letter) => `<div class="cell">${escapeHtml(letter)}</div>`)
                    .join("")}
                </div>
                <div class="keywords">
                  <span class="label">Słowa kluczowe:</span>
                  <span class="value">${formatInlineHTML(keywords)}</span>
                </div>
                <div class="stats labels">
                  ${Object.keys(stats)
                    .map((key) => `<div class="cell">${escapeHtml(key)}</div>`)
                    .join("")}
                </div>
                <div class="stats values">
                  ${Object.values(stats)
                    .map((val) => `<div class="cell">${escapeHtml(val)}</div>`)
                    .join("")}
                </div>
                <div class="section-header centered">Odporność</div>
                <div class="section-body centered">${resistanceLine}</div>
                ${armorTraitsHTML}
                <div class="triple labels">
                  <div class="cell">Obrona</div>
                  <div class="cell">Żywotność</div>
                  <div class="cell">Odporność psych.</div>
                </div>
                <div class="triple values">
                  <div class="cell">${escapeHtml(defense)}</div>
                  <div class="cell">${escapeHtml(vitality)}</div>
                  <div class="cell">${escapeHtml(mental)}</div>
                </div>
                ${trackerHTML}
                ${sectionHTML}
                <div class="quad labels">
                  <div class="cell">Upór</div>
                  <div class="cell">Odwaga</div>
                  <div class="cell">Szybkość</div>
                  <div class="cell">Rozmiar</div>
                </div>
                <div class="quad values">
                  <div class="cell">${escapeHtml(grit)}</div>
                  <div class="cell">${escapeHtml(courage)}</div>
                  <div class="cell">${escapeHtml(speed)}</div>
                  <div class="cell">${escapeHtml(size)}</div>
                </div>
                ${notesHTML}
              </div>
              <script>
                const updateTrackerLayout = () => {
                  document.querySelectorAll(".tracker-grid").forEach((grid) => {
                    const style = getComputedStyle(grid);
                    const size = parseFloat(style.getPropertyValue("--tracker-size")) || 18;
                    const gap = parseFloat(style.getPropertyValue("--tracker-gap")) || 1;
                    const count = Number(grid.dataset.count || 0);
                    const available = grid.clientWidth - gap * 2;
                    const rawColumns = Math.floor((available + gap) / (size + gap));
                    const minColumns = count > 0 ? 2 : 1;
                    const columns = Math.max(minColumns, rawColumns);
                    grid.style.setProperty("--tracker-columns", columns);
                    const slotsPerRow = Math.max(columns - 1, 1);
                    const rows = count > 0 ? Math.ceil(count / slotsPerRow) : 1;
                    grid.style.setProperty("--tracker-rows", rows);
                  });
                };
                window.addEventListener("load", updateTrackerLayout);
                window.addEventListener("resize", updateTrackerLayout);
              </script>
            </body>
          </html>
        `;
      };

      const openPrintableCard = (record, notes, overrides) => {
        const html = buildPrintableCardHTML(record, notes, overrides);
        const printWindow = window.open("", "_blank");
        if (!printWindow) {
          alert("Nie udało się otworzyć nowej karty. Sprawdź blokadę pop-upów.");
          return;
        }
        printWindow.document.open();
        printWindow.document.write(html);
        printWindow.document.close();
      };

      const attachListeners = () => {
        bestiarySelect.addEventListener("change", updateBestiarySelection);
        armorSelect.addEventListener("change", renderArmorTable);
        weaponSelect.addEventListener("change", renderWeaponTable);
        augmentationsSelect.addEventListener("change", renderAugmentationsTable);
        equipmentSelect.addEventListener("change", renderEquipmentTable);
        talentsSelect.addEventListener("change", renderTalentsTable);
        psionicsSelect.addEventListener("change", renderPsionicsTable);
        prayersSelect.addEventListener("change", renderPrayersTable);
        moduleToggles.forEach((toggle) => {
          toggle.addEventListener("change", updateModuleVisibility);
        });
        resetButton.addEventListener("click", () => {
          bestiarySelect.selectedIndex = 0;
          state.selectedBestiaryIndex = null;
          Array.from(armorSelect.options).forEach((option) => {
            option.selected = false;
          });
          Array.from(weaponSelect.options).forEach((option) => {
            option.selected = false;
          });
          Array.from(augmentationsSelect.options).forEach((option) => {
            option.selected = false;
          });
          Array.from(equipmentSelect.options).forEach((option) => {
            option.selected = false;
          });
          Array.from(talentsSelect.options).forEach((option) => {
            option.selected = false;
          });
          Array.from(psionicsSelect.options).forEach((option) => {
            option.selected = false;
          });
          Array.from(prayersSelect.options).forEach((option) => {
            option.selected = false;
          });
          moduleToggles.forEach((toggle) => {
            toggle.checked = toggle.defaultChecked;
          });
          bestiaryNotes.value = "";
          resetBestiaryOverrides();
          armorTraitDescriptionsToggle.checked = armorTraitDescriptionsToggle.defaultChecked;
          weaponTraitDescriptionsToggle.checked = weaponTraitDescriptionsToggle.defaultChecked;
          augmentationsFullDetailsToggle.checked = augmentationsFullDetailsToggle.defaultChecked;
          equipmentFullDetailsToggle.checked = equipmentFullDetailsToggle.defaultChecked;
          talentsFullDetailsToggle.checked = talentsFullDetailsToggle.defaultChecked;
          psionicsFullDetailsToggle.checked = psionicsFullDetailsToggle.defaultChecked;
          prayersFullDetailsToggle.checked = prayersFullDetailsToggle.defaultChecked;
          popover.classList.remove("active");
          state.expandedCells.clear();
          renderBestiaryTable(null);
          setArmorSelectionEnabled(true);
          renderArmorTable();
          renderWeaponTable();
          renderAugmentationsTable();
          renderEquipmentTable();
          renderTalentsTable();
          renderPsionicsTable();
          renderPrayersTable();
          updateModuleVisibility();
        });
        generateButton.addEventListener("click", () => {
          const index = Number(bestiarySelect.value);
          if (Number.isNaN(index) || !state.bestiary[index]) {
            alert("Wybierz rekord bestiariusza, aby wygenerować kartę.");
            return;
          }
          const selectedWeapons = getSelectedRecords(state.weapons, getSelectedIndices(weaponSelect));
          const selectedArmor = getSelectedRecords(state.armor, getSelectedIndices(armorSelect));
          const selectedAugmentations = getSelectedRecords(state.augmentations, getSelectedIndices(augmentationsSelect));
          const selectedEquipment = getSelectedRecords(state.equipment, getSelectedIndices(equipmentSelect));
          const selectedTalents = getSelectedRecords(state.talents, getSelectedIndices(talentsSelect));
          const selectedPsionics = getSelectedRecords(state.psionics, getSelectedIndices(psionicsSelect));
          const selectedPrayers = getSelectedRecords(state.prayers, getSelectedIndices(prayersSelect));
          const weaponOverride = buildWeaponOverride(selectedWeapons, {
            includeTraitDescriptions: weaponTraitDescriptionsToggle.checked,
          });
          const armorOverride = getArmorOverrides(selectedArmor, {
            includeTraitDescriptions: armorTraitDescriptionsToggle.checked,
          });
          const moduleEntries = [
            {
              label: "Augumentacje",
              value: buildModuleEntries(selectedAugmentations, augmentationsColumns, {
                includeFull: augmentationsFullDetailsToggle.checked,
              }),
            },
            {
              label: "Ekwipunek",
              value: buildModuleEntries(selectedEquipment, equipmentColumns, {
                includeFull: equipmentFullDetailsToggle.checked,
              }),
            },
            {
              label: "Talenty",
              value: buildModuleEntries(selectedTalents, talentsColumns, {
                includeFull: talentsFullDetailsToggle.checked,
              }),
            },
            {
              label: "Psionika",
              value: buildModuleEntries(selectedPsionics, psionicsColumns, {
                includeFull: psionicsFullDetailsToggle.checked,
                normalizeColumns: ["Wzmocnienie"],
              }),
            },
            {
              label: "Modlitwy",
              value: buildModuleEntries(selectedPrayers, prayersColumns, {
                includeFull: prayersFullDetailsToggle.checked,
              }),
            },
          ];
          openPrintableCard(state.bestiary[index], bestiaryNotes.value, {
            weaponOverride,
            armorOverride,
            moduleEntries,
            bestiaryOverrides: state.bestiaryOverrides,
          });
        });
      };

      const loadData = async () => {
        setStatus("Ładowanie danych...");
        state.expandedCells.clear();
        bestiarySelect.disabled = true;
        armorSelect.disabled = true;
        weaponSelect.disabled = true;
        augmentationsSelect.disabled = true;
        equipmentSelect.disabled = true;
        talentsSelect.disabled = true;
        psionicsSelect.disabled = true;
        prayersSelect.disabled = true;
        try {
          const response = await fetch(DATA_URL, { cache: "no-store" });
          if (!response.ok) {
            throw new Error(`Błąd pobierania: ${response.status}`);
          }
          const data = await response.json();
          state.data = data;
          state.traits = buildTraitsMap(data);
          state.bestiary = sortByName(getCollection(data, ["besti", "bestiariusz"]));
          state.armor = sortByTypeThenName(getCollection(data, ["pancerz", "armor"]));
          state.weapons = sortByTypeThenName(getCollection(data, ["broń", "bron", "weapon"]));
          state.augmentations = sortByTypeThenName(getCollection(data, ["augument", "augment", "modyfikac"]));
          state.equipment = sortByTypeThenName(getCollection(data, ["ekwipunek", "equipment"]));
          state.talents = sortByName(getCollection(data, ["talent"]));
          state.psionics = sortByTypeThenName(getCollection(data, ["psion", "psionik"]), {
            typeDescending: true,
          });
          state.prayers = sortByName(getCollection(data, ["modlitw", "prayer"]));
          setSelectOptions(bestiarySelect, state.bestiary, "Wybierz nazwę...");
          setSelectOptions(armorSelect, state.armor, "Wybierz pancerze...", {
            disableOption: isArmorBlocked,
            disabledTitle: "Pancerz z WP '-' nie może być wybrany.",
          });
          setSelectOptions(weaponSelect, state.weapons, "Wybierz bronie...");
          setSelectOptions(augmentationsSelect, state.augmentations, "Wybierz augumentacje...");
          setSelectOptions(equipmentSelect, state.equipment, "Wybierz ekwipunek...");
          setSelectOptions(talentsSelect, state.talents, "Wybierz talenty...");
          setSelectOptions(psionicsSelect, state.psionics, "Wybierz psionikę...");
          setSelectOptions(prayersSelect, state.prayers, "Wybierz modlitwy...");
          setStatus(
            `Załadowano: Bestiariusz (${state.bestiary.length}), Pancerze (${state.armor.length}), Bronie (${state.weapons.length}), Augumentacje (${state.augmentations.length}), Ekwipunek (${state.equipment.length}), Talenty (${state.talents.length}), Psionika (${state.psionics.length}), Modlitwy (${state.prayers.length}).`
          );
          renderBestiaryTable(null);
          renderArmorTable();
          renderWeaponTable();
          renderAugmentationsTable();
          renderEquipmentTable();
          renderTalentsTable();
          renderPsionicsTable();
          renderPrayersTable();
        } catch (error) {
          setStatus("Nie udało się pobrać danych. Sprawdź CORS i dostępność źródła.");
          clearTableBody(bestiaryTableBody, "Brak danych do wyświetlenia.", 2);
          clearTableBody(armorTableBody, "Brak danych do wyświetlenia.", 6);
          clearTableBody(weaponTableBody, "Brak danych do wyświetlenia.", 10);
          clearTableBody(augmentationsTableBody, "Brak danych do wyświetlenia.", 2);
          clearTableBody(equipmentTableBody, "Brak danych do wyświetlenia.", 2);
          clearTableBody(talentsTableBody, "Brak danych do wyświetlenia.", 2);
          clearTableBody(psionicsTableBody, "Brak danych do wyświetlenia.", 8);
          clearTableBody(prayersTableBody, "Brak danych do wyświetlenia.", 2);
          setSelectOptions(bestiarySelect, [], "");
          setSelectOptions(armorSelect, [], "");
          setSelectOptions(weaponSelect, [], "");
          setSelectOptions(augmentationsSelect, [], "");
          setSelectOptions(equipmentSelect, [], "");
          setSelectOptions(talentsSelect, [], "");
          setSelectOptions(psionicsSelect, [], "");
          setSelectOptions(prayersSelect, [], "");
        }
      };

      document.addEventListener("click", (event) => {
        const tag = event.target.closest(".tag");
        if (tag) {
          const traitName = tag.getAttribute("data-trait") || tag.textContent;
          popoverTitle.textContent = traitName;
          popoverDescription.textContent = resolveTraitDescription(traitName);
          popover.classList.add("active");
          return;
        }
        if (!event.target.closest(".popover")) {
          popover.classList.remove("active");
        }
      });

      attachListeners();
      updateModuleVisibility();
      loadData();
    </script>
  </body>
</html>
